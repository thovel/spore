#!/bin/bash

# The outstanding-policies command will emit commands that are needed
# to be run in order for the local system to comply with a policy


## Get the configuration value of a key $2 from section $1 from a
## ini-file config file $2.
function get() {
  # first look for any section of the file between a [$2] and a [
  # Within that ({}) look for the "$3 =" with any whitespace interspersed.
  # If you find it, remove everything up to the first "=".
  # "I" is for case insensitive.
  sed -n "/^[[:space:]]*\[$2\]/I,/^\[/ {
            /^[[:space:]]*$3[[:space:]]*=[[:space:]]*/Is/[^=]*=[[:space:]]*//p
          }" "$1" | head -n 1
}


## Ensures that the directory $2 exists, and if it isn't
## create it with the specified octal mode $1.
function ensure_dir_exists() {
  if [ ! -d $sshdir ] ; then
    echo "mkdir --mode $1 '$2'"
    return 1
  fi
}


## Ensures that the permissions $1 are set for a file $2
function ensure_permissions() {
  local perms="$(stat -c %a "$2")"
  if [ "$perms" != "$1" ] ; then
    echo "chmod $1 '$2'"
    return 1
  fi
}


## Ensures that a user $1 owns a file $2
function ensure_user_owns() {
  local owner="$(stat -c %U "$2")"
  if [ "$owner" != "$1" ] ; then
    echo "chown $1: '$2'"
    return 1
  fi
}


## Ensures that keys in a keyfile $1 are present for a user's
## authorized_keys file $2.
## If the keyfile contains more than one key, abort
function ensure_key_present() {
  # Algorithm:
  # read each line,
  # if any line is identical to $2, return
  # if end of loop, emit command to add to the file.
  local keyline=$(< "$1")
  if [ -r $2 ] ; then
    while read line ; do
      if [ "$line" == "$keyline" ] ; then
        # We found it!  Nothing to do here
        return
      fi
    done < "$2"
  fi
  # $keyline was not found...
  # TODO: remove apostrophes in output? ugh...
  echo echo \'${keyline}\' '|' tee '>'/dev/null -a \'"$2"\'
  return 1
}

## Ensures that the key in a keyfile $1 are absent (and removed if
## they're found) for a user's authorized_keys file $2.
## If the keyfile contains more than one key, abort
function ensure_key_absent() {
  local key="$(sed < "$1" -n 's/.*\b\(ssh-dss\|ssh-rsa\) \([^ ]*\).*/\2/p')"
  if [ -z "$key" ] ; then
    echo "# unable to parse key file $1 for blacklisting."
    return
  fi
  if [ -r "$2" ] ; then
    if grep > /dev/null $key "$2" ; then
      echo 'sed -i '\''\,'"$key"',d'\' \'$2\'
      return 1
    fi
  fi
}

## Ensures that the .ssh/authorized_keys has the keys
## listed in the ssh-keys directories, but none of the
## keys that have been revoked.
function ensure_ssh_keys() {
  local keydir="$1/ssh-keys"
  if [ ! -d "$keydir" ] ; then
    echo "# ignoring $user_name's keys, since keydir $keydir is missing."
    return 0
  fi
  sshdir=$(eval echo ~"$user_name"/.ssh)
  ensure_dir_exists 700 $sshdir || return 1
  ensure_user_owns $user_name $sshdir || return 1
  ensure_permissions 700 $sshdir || return 1
  local key
  for key in "$keydir/"*.pub ; do
    if [ -r "$key" ] ; then
      ensure_key_present $key $sshdir/authorized_keys || return 1
    fi
  done
  for key in "$keydir/"*.blacklisted ; do
    if [ -r "$key" ] ; then
      ensure_key_absent $key $sshdir/authorized_keys || return 1
    fi
  done
  if [ -r $sshdir/authorized_keys ] ; then
    ensure_user_owns $user_name $sshdir/authorized_keys || return 1
    ensure_permissions 600 $sshdir/authorized_keys || return 1
  fi
  # TODO: ensure that no other keys are present (by counting them?)
  # e.g.
  # wc -l authorized_keys; ls -1 keydir/*.pub | wc -l
}

function ensure_policy_user() {
  local person="$1/person.ini"
  if [ ! -r "$person" ] ; then
    echo "# $person does not have a person definition."
    return;
  fi
  user_name=$(get "$person" user name)
  if [ -z "$user_name" ] ; then
    echo "# $person does not have a user_name; ignoring."
    return;
  fi
  if ! getent passwd $user_name >/dev/null; then
    echo "useradd --create-home $user_name"
    return
  fi

  user_groups=$(get "$person" user groups)
  local group;
  for group in $user_groups ; do
    # ensure group that the user should be added to exists
    if ! getent group $group >/dev/null; then
      echo "addgroup $user_name"
      return
    fi
    # Add the user to the group
    if ! group $user_name | grep > /dev/null '\b'"$group"'\b' ; then
      echo "addgroup $user_name $group"
      return
    fi
  done

  ensure_ssh_keys $1
}

function ensure_policy() {
  local dir
  for dir in "$1/users/"* ; do
    if [ -d "$dir" ] ; then
      ensure_policy_user "$dir"
    else
      echo "# ignoring non-directory $dir"
    fi
  done
}

policy=$1

[[ ! -z "$1" && -d "$1" ]] &&
  ensure_policy "$1"

