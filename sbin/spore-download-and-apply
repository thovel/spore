#!/bin/bash

spore_conf_file_name=noname
spore_name=noname
spore_file=nofile
spore_state_directory=nodir
spore_file_path=nopath
spore_signature_file_path=nopath
spore_metadata_file_path=nopath
spore_signature_metadata_file_path=nopath
apply_hook=nohook

## Logs the arguments to syslog
function log() {
  logger -t "$(basename "$0")[$$]" -- "${@}"
}



function usage() {
cat <<-EOF
	Usage: $0: [-a] [-c] [-d] [-v] [config_file[ config_file]]
	  -a : apply spores
	  -c : Check consistency of current state.
	  -d : download spores if they have changed
	  -v : verify signature of spores

  config_file :
    A path to a file that contains configuration information.
    default: /etc/spore/localhost.conf

  if any options are specified, only those options will be used.
  If more than one config_file is specified, "apply new spores" will be
  applied on the first conf file only.
  a consistency check and verification is allways executed before "apply new spores"

	The operations always run in this order:
	  1. verify existing spores  (-v)
	  2. consistency check       (-c)
	  3. download new spores     (-d)
	  4. verify new spores       (-v)
	  5. apply new spores        (-a)

	$0 is designed to be run as a cron job; as often as you feel it's
	necessary; either in hourly or daily, or maybe every few minutes.

	The "normal" state is that the spores have been downloaded and have
	been applied cleanly; in this state, the command will by default
	check consistency and do a conditional download of the spores; an
	operation that usually takes well less than a second of CPU time.

	Example crontab:

	  7-57/10 * * * * /usr/sbin/spore-download-and-apply

EOF
}

# Conditionally download $1 to $2 using $3 as metadata.
function conditional_get() {
  if [ -r "$3" ] ; then
    local metadata=$(cat "$3")
  fi
  shopt -s nocasematch
  shopt -s nocaseglob
  if [[ $metadata == etag:* ]] ; then
    local conditional=( "--header" "If-None-Match: $(echo ${metadata} | sed s/^etag://i )" )
  elif [[ $metadata == last-modified* ]] ; then
    local conditional=( "--header" "If-Modified-Since: $(echo "${metadata}" | sed s/^last-modified://i)" )
  fi
  local tmpfile=$(mktemp)
  local tmpmeta=$(mktemp)
  curl "${conditional[@]}" $curl_opts $1 --dump-header $tmpmeta > $tmpfile
  sed -i s/'\r'// $tmpmeta

  read httpver responsestatus responsetext <<< $(grep ^HTTP/ $tmpmeta | tail -n 1)
  if [ "$responsestatus" != "200" ] ; then
    rm $tmpfile $tmpmeta
    return 1
  fi

  if [ ! -s $tmpfile ] ; then
    echo "unable to download $1; empty"
    rm $tmpfile $tmpmeta
    return 1
  fi

  mv "${tmpfile}" "${2}"

  local meta=$( grep -i "^ETag:" "$tmpmeta" | head -n 1 )
  if [ -z "$meta" ] ; then
    meta=$( grep -i "^last-modified:" "$tmpmeta" | head -n 1 )
  fi
  if [ ! -z "$meta" ] ; then
    echo "$meta" > $3
  fi
  rm $tmpmeta
}


function do_download_spores() {
  if [ $download_spores -eq 0 ] ; then
    return 0
  fi

  download_skipped=1
  if conditional_get $spore_uri $spore_file_path $spore_metadata_file_path ; then 
    download_skipped=0
    log "New spores downloaded from $spore_uri to $spore_file_path"
  fi
  if conditional_get $spore_signature_uri $spore_signature_file_path $spore_signature_metadata_file_path ; then
    download_skipped=0
  fi
  if [ $download_skipped -eq 1 ] ; then
     log "no download needed; $spore_file_path and $spore_uri are identical"
  fi
  return $download_skipped
}


function do_verify_spores() {
  if [ $verify_spores -eq 0 ] ; then
    return
  fi

  if [ ! -r $spore_file_path ] ; then
    log "spores don't exist yet, nothing to verify, nothing to find \"invalid\""
    return 0
  fi

  gpg_status=$(mktemp)
  gpg 2> /dev/null --status-fd 1 $gpg_opts --verify $spore_signature_file_path > $gpg_status
  local rc=$PIPESTATUS
  if [ $rc != 0 ] ; then
    log "gpg failed (rc $rc) to verify signature, $spore_signature_uri maybe tampered with."
    rm $gpg_status
    return 1
  fi

  if ! grep -q "GOODSIG.*$spore_signee" $gpg_status ; then
    log "Signature did not match requested signees.  $(grep GOODSIGN $gpg_status)."
    rm $gpg_status
    return 1
  fi

  log "Good signature from $spore_signee in ${spore_signature_file_path}"
  rm $gpg_status
}

function do_apply_spores() {
  if [ $apply_spores -eq 0 ] ; then
    return
  fi
  tmpdir=$(mktemp -d)
  log "Applying spores"
  cd $tmpdir && tar xzf $spore_file_path && $apply_hook apply . $spore_state_directory $spore_name && cd && rm -rf $tmpdir
}

function do_check_consistency_of_spores() {
  if [ $check_consistency_of_spores -eq 0 ] ; then
    return 0
  fi
  if [ ! -r $spore_file_path ] ; then
    log "No spores at $spore_file_path, skipping consistency check."
    return 0
  fi

  tmpdir=$(mktemp -d)
  cd $tmpdir
  tar xzf $spore_file_path
  lines=$($apply_hook next . $spore_state_directory $spore_name | grep -v ^# | wc -l)
  cd
  rm -rf $tmpdir
  if [ $lines -ne 0 ] ; then
    log "Internal consistency check failed; old spores don't match current state."
    return 1
  else
    log "Internal consistency check succeded; old spores match current state."
    return 0
  fi
}


function doit {


curl_opts="$curl_opts -s"

if [ -z "$spore_uri" ] ; then
  echo "spore_uri mandatory, not set."
  exit 2
fi

if [ ! -z "$http_user" ] && [ ! -z "$http_passwd" ] ; then
  curl_opts="$curl_opts --user $http_user:$http_passwd"
elif [ ! -z "$http_user" ] ; then
  curl_opts="$curl_opts --user $http_user"
fi

if [ -z "$spore_signature_uri" ] ; then
  spore_signature_uri="$spore_uri.asc"
fi


if ! do_verify_spores ; then
  echo "The currently downloaded spores can't be trusted."
  exit 1
elif ! do_check_consistency_of_spores ; then
  echo "The system does not adhere to the currently downloaded spores."
  exit 1
elif ! do_download_spores ; then
  echo "The spores have not changed."
  exit 0
elif ! do_verify_spores ; then
  echo "The downloaded spores can't be trusted."
  exit 1
elif ! do_apply_spores ; then
  echo "The spores failed to apply cleanly."
  exit 1
else
  exit 0
fi

}



check_consistency_of_spores=0
apply_spores=0
download_spores=0
verify_spores=0
conf_file_argument_count=0
default_operation=1
conf_file_arguments=()
default_conf_file=1

optionparsing=1

while [ $# -gt 0 ] ; do

  if [[ $1 == -* ]] ; then

    if [[ $optionparsing -eq 0 ]] ; then
      echo "options staring with a dash cannot be mixed with filenames"
      usage
      exit 2
    fi

    if [ "$1" == "-a" ] ; then
      apply_spores=1
      default_operation=0
    fi
    if [ "$1" == "-d" ] ; then
      download_spores=1
      default_operation=0
    fi
    if [ "$1" == "-c" ] ; then
      check_consistency_of_spores=1
      default_operation=0
    fi
    if [ "$1" == "-v" ] ; then
      verify_spores=1
      default_operation=0
    fi

  else
    optionparsing=0

    if [[ ! $1 =~ ^[a-z]{2,20}\.conf$ ]] ; then
      echo "the filename of $1 must be lowercase characters and have .conf as an extention"
      usage
      exit 2
    fi
  
    if [ -f $1 ] ; then
#    echo "$1 is a file"
      default_conf_file=0
      conf_file_argument_count=conf_file_argument_count+1
      conf_file_arguments+=($1)
    else
      echo "$1 is not a file"
      usage
      exit 2
    fi
  fi
  
  shift;
  
done



#echo "default_conf_file=$default_conf_file"

if [ $default_conf_file -eq 0 ] ; then
  for conf_file in "${conf_file_arguments[@]}"
  do
#    echo "source $conf_file"


    spore_conf_file_name=$conf_file
    spore_name=$(echo $spore_conf_file_name | sed -n 's/\(.*\)\.conf/\1/p')
    spore_state_directory=/var/lib/spore/

#    echo "default spore_name: $spore_name"
#    echo "default spore_state_directory: $spore_state_directory"

    source $conf_file

    spore_file="${spore_name}.tar.gz"
    spore_file_path="${spore_state_directory}${spore_file}"
    spore_signature_file_path="${spore_file_path}.asc" 
    spore_metadata_file_path="${spore_state_directory}${spore_name}.metadata"
    spore_signature_metadata_file_path="${spore_state_directory}${spore_name}.asc.metadata"

    if [ $default_operation -ne 0 ] ; then
  
      if [[ $actions =~ verify ]] ; then
        verify_spores=1
      fi
  
      if [[ $actions =~ check-consistency ]] ; then
        check_consistency_of_spores=1
      fi

      if [[ $actions =~ apply ]] ; then
        apply_spores=1
      fi
      if [[ $actions =~ download ]] ; then
        download_spores=1
      fi
    fi

    
#    echo "spore_name: $spore_name"
#    echo "spore_state_directory: $spore_state_directory"
#    echo "spore_conf_file_name: $spore_conf_file_name"
#    echo "spore_file: $spore_file"
#    echo "spore_file_path: $spore_file_path"
#    echo "spore_signature_file_path: $spore_signature_file_path"
#    echo "spore_metadata_file_path: $spore_metadata_file_path"
#    echo "spore_signature_metadata_file_path: $spore_signature_metadata_file_path"


    
    doit
  done
else

  if [ -r /etc/spore/localhost.conf ] ; then
    source /etc/spore/localhost.conf
  else
    cat <<- 'EOF'

  By default this command will look for a file: /etc/spore/localhost.conf
  You can also put it somewhere else but we appreciate a .../spore/*.conf pattern

  The filename is used to discover the default sporename
  For this reason, a spore configuration file name must allways adhere to ^[a-z]{2,20}.conf$  

  The following variables are used during the run of this command

  If our spore name is cocacola then:

  - spore_conf_file_name=spore-cocacola.conf
  - spore_name=cocacola
  - spore_file=cocacola.tar.gz
  - spore_state_directory=/var/lib/spore/

  The contents of a configuration file should be:

    # spore_name and target_directory can be overriidden
    # spore_conf_file_name and spore_file cannot be overridden

    # The actions to run if no parameters are given
    actions="verify check-consistency download verify apply"

    # The apply hook used
    apply-hook=ubuntuusers

    # The URI of a .tar.gz file containing spores
    spore_uri=http://some/ur/of/a/spore.tar.gz

    # The URI of the signature, defaults to "${spore_uri}.asc"
	  # spore_signature_uri=http://some/ur/of/a/spore.tar.gz.asc

	  # If the spore or signature are protected by password, specify them here
    # if ther http_user is empty or only has whitespace, no credentials will be sent added to the request
	  http_user=someuser
	  http_passwd=somepasswd

	  # GPG ID of the trusted signatures.
    # This keys should be confugures as:
    # - available in the keyring 
    # - have a trustlevel of "full" or be signed by enough trusted keys.
    # - adhere to [0-1A-F]{40}
	  spore_signee=0123456789ABCDEF0123456789ABCDEF01234567


	The file will be sourced from bash.
	EOF
  exit 2
  fi
fi

